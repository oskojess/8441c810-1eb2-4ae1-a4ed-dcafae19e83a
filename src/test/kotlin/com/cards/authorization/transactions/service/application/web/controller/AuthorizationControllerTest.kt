package com.cards.authorization.transactions.service.application.web.controllerimport com.cards.authorization.transactions.service.application.service.AuthorizationServiceimport com.cards.authorization.transactions.service.application.web.controller.authorization.dto.request.toTransactionDTOimport com.cards.authorization.transactions.service.application.web.controller.authorization.dto.response.TransactionResponseimport com.cards.authorization.transactions.service.common.AbstractInitializeTestimport com.cards.authorization.transactions.service.common.AccountBuilder.buildAccountimport com.cards.authorization.transactions.service.common.Constants.ACCOUNT_IDimport com.cards.authorization.transactions.service.common.TransactionBuilder.buildTransactionimport com.cards.authorization.transactions.service.domain.account.AccountRepositoryimport com.cards.authorization.transactions.service.repositories.database.account.entity.toDomainimport io.mockk.everyimport io.mockk.mockkimport io.mockk.unmockkAllimport org.junit.jupiter.api.Testimport org.springframework.http.HttpStatusimport org.springframework.http.ResponseEntityimport java.math.BigDecimalimport kotlin.test.assertEqualsinternal class AuthorizationControllerTest : AbstractInitializeTest() {    private val authorizationService = mockk<AuthorizationService>()    private val accountRepository = mockk<AccountRepository>()    private val authorizationController = AuthorizationController(authorizationService, accountRepository)    override fun afterEach() {        unmockkAll()    }    @Test    fun `must be receive an authorization intent for a transaction and the return of a successfully approved transaction`() {        val transactionRequest = buildTransaction(totalAmount = BigDecimal(30.00))        val account = buildAccount().toDomain()        val transactionDTO = transactionRequest.toTransactionDTO()        val responseCode = "00"        val expectedResponse = TransactionResponse(responseCode)        every { accountRepository.findByAccountId(ACCOUNT_ID) } returns account        every { authorizationService.authorize(account, transactionDTO) } returns responseCode        val response = authorizationController.authorizeTransactions(transactionRequest)        assertEquals(ResponseEntity.ok(expectedResponse), response)        assertEquals(HttpStatus.OK, response.statusCode)        assertEquals(expectedResponse, response.body)    }    @Test    fun `must be receive an authorization intent for a transaction and the return of a successfully insufficient balance transaction`() {        val transactionRequest = buildTransaction(totalAmount = BigDecimal(40000.00))        val account = buildAccount().toDomain()        val transactionDTO = transactionRequest.toTransactionDTO()        val responseCode = "51"        val expectedResponse = TransactionResponse(responseCode)        every { accountRepository.findByAccountId(ACCOUNT_ID) } returns account        every { authorizationService.authorize(account, transactionDTO) } returns responseCode        val response = authorizationController.authorizeTransactions(transactionRequest)        assertEquals(ResponseEntity.ok(expectedResponse), response)        assertEquals(HttpStatus.OK, response.statusCode)        assertEquals(expectedResponse, response.body)    }    @Test    fun `must be receive an authorization intent for a transaction and the return of a successfully other error transaction`() {        val transactionRequest = buildTransaction(totalAmount = BigDecimal(40000.00))        val account = buildAccount().toDomain()        val transactionDTO = transactionRequest.toTransactionDTO()        val responseCode = "07"        val expectedResponse = TransactionResponse(responseCode)        every { accountRepository.findByAccountId(ACCOUNT_ID) } returns account        every { authorizationService.authorize(account, transactionDTO) } returns responseCode        val response = authorizationController.authorizeTransactions(transactionRequest)        assertEquals(ResponseEntity.ok(expectedResponse), response)        assertEquals(HttpStatus.OK, response.statusCode)        assertEquals(expectedResponse, response.body)    }}