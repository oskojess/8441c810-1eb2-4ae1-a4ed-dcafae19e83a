package com.cards.authorization.transactions.service.application.service.strategyimport com.cards.authorization.transactions.service.application.service.type.AuthorizationCode.APPROVEDimport com.cards.authorization.transactions.service.application.service.type.AuthorizationCode.INSUFFICIENT_BALANCEimport com.cards.authorization.transactions.service.application.web.controller.authorization.dto.request.toTransactionDTOimport com.cards.authorization.transactions.service.common.AbstractInitializeTestimport com.cards.authorization.transactions.service.common.AccountBuilder.buildAccountimport com.cards.authorization.transactions.service.common.Constants.ACCOUNT_IDimport com.cards.authorization.transactions.service.common.TransactionBuilder.buildTransactionimport com.cards.authorization.transactions.service.domain.account.AccountRepositoryimport com.cards.authorization.transactions.service.repositories.database.account.entity.toDomainimport io.mockk.everyimport io.mockk.mockkimport io.mockk.unmockkAllimport org.junit.jupiter.api.Testimport java.math.BigDecimalimport kotlin.test.assertEqualsinternal class CashCategoryAuthorizationStrategyTest : AbstractInitializeTest() {    private val accountRepository = mockk<AccountRepository>(relaxed = true)    private val cashCategoryAuthorizationStrategy = CashCategoryAuthorizationStrategy(accountRepository)    override fun afterEach() {        unmockkAll()    }    @Test    fun `must be authorize transaction then return APPROVED when balance sufficent `() {        val account = buildAccount().toDomain()        val transaction = buildTransaction(totalAmount = BigDecimal(50.00)).toTransactionDTO()        val approved = APPROVED        every { accountRepository.findByAccountId(ACCOUNT_ID) } returns account        val result = cashCategoryAuthorizationStrategy.evaluateAuthorization(account, transaction)        assertEquals(approved, result)    }    @Test    fun `must be NOT authorize transaction then return INSUFFICENT_BALANCE when balance insufficient `() {        val account = buildAccount().toDomain()        val transaction = buildTransaction(totalAmount = BigDecimal(4000.00)).toTransactionDTO()        val insufficientBalance = INSUFFICIENT_BALANCE        every { accountRepository.findByAccountId(ACCOUNT_ID) } returns account        val result = cashCategoryAuthorizationStrategy.evaluateAuthorization(account, transaction)        assertEquals(insufficientBalance, result)    }}