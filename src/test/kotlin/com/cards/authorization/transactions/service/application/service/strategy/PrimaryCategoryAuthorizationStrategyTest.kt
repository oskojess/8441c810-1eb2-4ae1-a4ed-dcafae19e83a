package com.cards.authorization.transactions.service.application.service.strategyimport com.cards.authorization.transactions.service.application.service.type.AuthorizationCode.APPROVEDimport com.cards.authorization.transactions.service.application.service.type.AuthorizationCode.INSUFFICIENT_BALANCEimport com.cards.authorization.transactions.service.application.web.controller.authorization.dto.request.toTransactionDTOimport com.cards.authorization.transactions.service.common.AbstractInitializeTestimport com.cards.authorization.transactions.service.common.AccountBuilderimport com.cards.authorization.transactions.service.common.Constantsimport com.cards.authorization.transactions.service.common.TransactionBuilder.buildTransactionimport com.cards.authorization.transactions.service.domain.account.AccountRepositoryimport com.cards.authorization.transactions.service.repositories.database.account.entity.toDomainimport io.mockk.everyimport io.mockk.mockkimport io.mockk.unmockkAllimport org.junit.jupiter.api.Assertions.assertEqualsimport org.junit.jupiter.api.Testimport java.math.BigDecimalclass PrimaryCategoryAuthorizationStrategyTest : AbstractInitializeTest() {    private val accountRepository = mockk<AccountRepository>(relaxed = true)    private val primaryCategoryAuthorizationStrategy = PrimaryCategoryAuthorizationStrategy(accountRepository)    override fun afterEach() {        unmockkAll()    }    @Test    fun `must be authorize transaction then return APPROVED when balance sufficient `() {        val account = AccountBuilder.buildAccount().toDomain()        val transaction = buildTransaction(totalAmount = BigDecimal(10.00)).toTransactionDTO()        val approved = APPROVED        every { accountRepository.findByAccountId(Constants.ACCOUNT_ID) } returns account        val result = primaryCategoryAuthorizationStrategy.evaluateAuthorization(account, transaction)        assertEquals(approved, result)    }    @Test    fun `must be not authorize transaction then return INSUFFICENT_BALANCE when balance insufficient `() {        val account = AccountBuilder.buildAccount().toDomain()        val transaction = buildTransaction(totalAmount = BigDecimal(500.00)).toTransactionDTO()        val insufficientBalance = INSUFFICIENT_BALANCE        every { accountRepository.findByAccountId(Constants.ACCOUNT_ID) } returns account        val result = primaryCategoryAuthorizationStrategy.evaluateAuthorization(account, transaction)       assertEquals(insufficientBalance, result)    }}